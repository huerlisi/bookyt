# The API module serves as namespace for all Bookyt API related
# classes and modules.
#
# The API needs to be versioned by using version namespaces and [Versionist](https://github.com/bploetz/versionist).
#
# All API controllers needs to inherit from {Api::ApiController}.
#
module Api

  # The V1 namespace is used for the Bookyt API version 1,
  # which is also the latest version.
  #
  module V1
  end

  # The ApiController is the base class for all controllers
  # handling API requests.
  #
  # All API controllers needs an authenticated user by default,
  # otherwise you need so use {.no_authentication!} to not
  # authenticate the user.
  #
  # All model data must be loaded and authorized by [CanCan](https://github.com/ryanb/cancan)
  # via {#load_and_authorize_resource}.
  #
  # The API base controller handles common exception cases and sends the proper HTTP status
  # response.
  #
  # The common generic response format is generated by {Responder::ApplicationResponder},
  # so the controllers needs to send the model data to respond with with `#respond_with` to
  # the responder.
  #
  class ApiController < ActionController::Base

    respond_to :json

    layout nil

    ### Rescues

    rescue_from CanCan::AccessDenied, with: :unauthorized!

    rescue_from ActiveRecord::RecordNotFound, with: :not_found!
    rescue_from ActiveRecord::StaleObjectError, with: :stale_object!

    rescue_from JSON::ParserError, with: :not_acceptable!

    ### Filters

    prepend_before_filter :auth_token

    before_filter :authenticate_user_from_token!

    private
    def authenticate_user_from_token!
      user_token = params[:auth_token].presence
      user       = user_token && User.find_by_authentication_token(user_token.to_s)

      if user
        sign_in user, store: false
      end
    end
    public

    before_filter :authenticate!
    before_filter :skip_trackable

    # All authentication is done via a secret token. This is not the default
    # behaviour of devise, but completly supported. Devise just expects
    # a parameter :auth_token set and will retrieve the corresponding user.
    #
    # This filter allows setting of the auth_token from different sources:
    #
    # * Request Parameters: The way it is expected by devise
    # * Session: Useful for callbacks not under our control (omniauth)
    # * Request Header: Used by APIs
    #
    # Set the devise authorization token request param
    # from the custom `Auth-Token` header. This allows the API usage
    # without signing in.
    #
    # see AuthenticationsController#create and OmniauthController for
    # setters of this token.
    def auth_token
      params[:auth_token] ||= request.headers['Auth-Token']
      params[:auth_token] ||= session[:authentication_token]
    end


    # Configure Devise that each API request doesn't count
    # as sign in.
    #
    def skip_trackable
      request.env['devise.skip_trackable'] = true
    end

    # Class level macro that removes the need of a authentication
    #
    def self.no_authentication!(options = {})
      skip_before_filter :authenticate!, options
    end

    # Makes sure the user is authenticated for the given request.
    #
    # If the user is not authenticated, the request is aborted with a 401 unauthorized status code and an error message.
    #
    # @example Missing authentication response (401)
    #  { :success => false, :message => "The user is not authenticated."}
    #
    def authenticate!
      unless current_user
        render json: { success: false, message: I18n.t('rest.unauthenticated') }, status: :unauthorized, text: ''
        false
      end
    end

    # Returns a forbidden status when the current {Ability} is not sufficient. This method is called via the
    # CanCan::AccessDenied exception.
    #
    # If the user is not authorized, the request is aborted with a 403 forbidden status code and an error message.
    #
    # @example Missing authorization response (403)
    #  { :success => false, :message => "Not allowed to manage other user accounts."}
    #
    def unauthorized!(exception)
      render json: { success: false, message: exception.message }, status: :forbidden, text: ''
    end

    # Returns a not found status when a resource is not found. This method is called via the ActiveRecord::RecordNotFound or
    # BSON::InvalidObjectId exception.
    #
    # The message depends on the controller and action that throws the exception and can be defined
    # under the I18n key not_found.controller_name.action_name.
    #
    # @example Not found response (404)
    #  { :success => false, :message => "Couldn't find Account with ID=1"}
    #
    def not_found!(exception = nil)
      message = I18n.t("rest.not_found.#{ controller_name }.#{ action_name }", default: I18n.t('rest.not_found.default'))
      render json: { success: false, message: message }, status: :not_found, text: ''
    end

    # Returns a not acceptable status when a resource is not acceptable. This method is called via the JSON::ParserError or
    # JSON::Schema::ValidationError exception.
    #
    # @example Not acceptable response (406)
    #  { :success => false, :message => "" }
    #
    def not_acceptable!(exception = nil)
      logger.error("Request not acceptable: #{ exception.message }") if exception
      render json: { success: false, message: I18n.t('rest.not_acceptable') }, status: :not_acceptable, text: ''
    end

    # Returns a conflict status when an object has been locked with optimistic locking and the lock
    # version did in fact change. This method is called via the ActiveRecord::StaleObjectError exception.
    #
    # @example Conflict response (409)
    #  { :success => false, :message => "Another user has changed the data already! Please reload the data."}
    #
    def stale_object! exception
      render json: { success: false, message: I18n.t('rest.stale_object') }, status: :conflict, text: ''
    end
  end
end
